import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import { account } from "./wallet.js";
import { validateEnvironment, getProvider, getSigner, getWalletAddress } from "./kuru/client.js";
import { getChainConfig, getSupportedChainNames } from "./config/chainConfig.js";
import { 
  getAllPools, 
  findBestPath, 
  executeSwap, 
  getTokenInfo, 
  estimateSwapOutput,
  getAvailableBaseTokens,
  validateTokenAddresses
} from "./tools/swapTools.js";

const server = new McpServer({
  name: "Kuru Exchange MCP",
  version: "1.0.0",
  description:
    "An MCP server for AI agents to interact with Kuru exchange operations using the Kuru SDK",
});

// Get Wallet Address Tool
server.tool(
  "getWalletAddress",
  "Get the wallet address derived from the private key in the environment variable",
  {},
  async () => {
    try {
      const validation = validateEnvironment();
      if (!validation.isValid) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå Environment validation failed:\n\n${validation.errors.join('\n')}\n\nRequired environment variables:\n‚Ä¢ PRIVATE_KEY\n‚Ä¢ KURU_API_URL\n‚Ä¢ RPC_URL`,
            },
          ],
        };
      }

      const chainConfig = getChainConfig();
      
      return {
        content: [
          {
            type: "text",
            text: `üí∞ **Wallet Address:**\n\n‚Ä¢ Address: ${account.address}\n‚Ä¢ Derived from: PRIVATE_KEY environment variable\n‚Ä¢ Chain: ${chainConfig.name} (${chainConfig.chainId})\n‚Ä¢ RPC URL: ${chainConfig.rpcUrl}\n‚Ä¢ Kuru API: ${chainConfig.kuruApiUrl}\n‚Ä¢ Status: ‚úÖ Ready for Kuru exchange operations\n\nüí° **Usage:** This address can be used for trading operations on Kuru exchange.\n\nüîó **Common Token Addresses:**\n‚Ä¢ **MON (Native):** 0x0000000000000000000000000000000000000000\n‚Ä¢ **USDC:** 0xf817257fed379853cDe0fa4F97AB987181B1E5Ea`,
          },
        ],
      };
    } catch (e) {
      return {
        content: [
          {
            type: "text",
            text: `‚ùå Failed to get wallet address: ${e}`,
          },
        ],
      };
    }
  }
);



// Get Chain Info Tool
server.tool(
  "getChainInfo",
  "Get information about the configured blockchain network",
  {},
  async () => {
    try {
      const chainConfig = getChainConfig();
      const supportedChains = getSupportedChainNames();
      
      return {
        content: [
          {
            type: "text",
            text: `üåê **Chain Information**\n\nüìã **Current Chain:**\n‚Ä¢ Name: ${chainConfig.name}\n‚Ä¢ Chain ID: ${chainConfig.chainId}\n‚Ä¢ Native Currency: ${chainConfig.nativeCurrency.name} (${chainConfig.nativeCurrency.symbol})\n‚Ä¢ Explorer: ${chainConfig.explorerUrl}\n‚Ä¢ RPC URL: ${chainConfig.rpcUrl}\n‚Ä¢ Kuru API: ${chainConfig.kuruApiUrl}\n\nüèóÔ∏è **Contracts:**\n‚Ä¢ Margin Account: ${chainConfig.contracts.marginAccount}\n‚Ä¢ Router: ${chainConfig.contracts.router}\n\nüí° **Important Token Information:**\n‚Ä¢ **MON** is the native token of Monad blockchain\n‚Ä¢ **Native Token Address:** 0x0000000000000000000000000000000000000000\n‚Ä¢ **USDC Address:** 0xf817257fed379853cDe0fa4F97AB987181B1E5Ea\n‚Ä¢ **Native tokens (MON) don't require approval for swaps**\n‚Ä¢ **ERC20 tokens (USDC) require approval before swapping**\n\nüìö **Supported Chains:**\n${supportedChains.map(chain => `‚Ä¢ ${chain}`).join('\n')}`,
          },
        ],
      };
    } catch (e) {
      return {
        content: [
          {
            type: "text",
            text: `‚ùå Failed to get chain info: ${e}`,
          },
        ],
      };
    }
  }
);



// Get All Pools Tool
server.tool(
  "getAllPools",
  "Get all available pools for a token pair using PoolFetcher",
  {
    tokenIn: z.string().describe("Input token address"),
    tokenOut: z.string().describe("Output token address"),
  },
  async (params) => {
    try {
      const validation = validateEnvironment();
      if (!validation.isValid) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå Environment validation failed:\n\n${validation.errors.join('\n')}`,
            },
          ],
        };
      }

      if (!validateTokenAddresses(params.tokenIn, params.tokenOut)) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå Invalid token addresses provided`,
            },
          ],
        };
      }

      const pools = await getAllPools(params.tokenIn, params.tokenOut);
      
      return {
        content: [
          {
            type: "text",
            text: `üèä **Available Pools Found**\n\nüìã **Token Pair:**\n‚Ä¢ Token In: ${params.tokenIn}\n‚Ä¢ Token Out: ${params.tokenOut}\n‚Ä¢ Total Pools: ${pools.length}\n\nüìä **Pool Details:**\n${pools.map((pool, index) => `‚Ä¢ Pool ${index + 1}: ${pool.baseToken} ‚Üí ${pool.quoteToken} (Orderbook: ${pool.orderbook})`).join('\n')}`,
          },
        ],
      };
    } catch (e) {
      return {
        content: [
          {
            type: "text",
            text: `‚ùå Failed to get pools: ${e}`,
          },
        ],
      };
    }
  }
);

// Find Best Path Tool
server.tool(
  "findBestPath",
  "Find the best path for a token swap using PathFinder",
  {
    tokenIn: z.string().describe("Input token address"),
    tokenOut: z.string().describe("Output token address"),
    amount: z.number().describe("Amount to swap (in number format, not ERC20 decimals)"),
    amountType: z.enum(["amountIn", "amountOut"]).optional().describe("Type of amount (default: amountIn)"),
  },
  async (params) => {
    try {
      const validation = validateEnvironment();
      if (!validation.isValid) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå Environment validation failed:\n\n${validation.errors.join('\n')}`,
            },
          ],
        };
      }

      if (!validateTokenAddresses(params.tokenIn, params.tokenOut)) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå Invalid token addresses provided`,
            },
          ],
        };
      }

      const bestPath = await findBestPath(
        params.tokenIn, 
        params.tokenOut, 
        params.amount, 
        params.amountType || "amountIn"
      );
      
      return {
        content: [
          {
            type: "text",
            text: `üõ£Ô∏è **Best Path Found**\n\nüìã **Swap Details:**\n‚Ä¢ Token In: ${params.tokenIn}\n‚Ä¢ Token Out: ${params.tokenOut}\n‚Ä¢ Amount: ${params.amount}\n‚Ä¢ Amount Type: ${params.amountType || "amountIn"}\n\nüìä **Path Information:**\n‚Ä¢ Amount Out: ${bestPath.amountOut}\n‚Ä¢ Path: ${bestPath.path?.join(' ‚Üí ') || 'Direct'}\n‚Ä¢ Pools Used: ${bestPath.pools?.length || 0}`,
          },
        ],
      };
    } catch (e) {
      return {
        content: [
          {
            type: "text",
            text: `‚ùå Failed to find best path: ${e}`,
          },
        ],
      };
    }
  }
);

// Estimate Swap Output Tool
server.tool(
  "estimateSwapOutput",
  "Estimate the output amount for a token swap",
  {
    tokenIn: z.string().describe("Input token address"),
    tokenOut: z.string().describe("Output token address"),
    amountIn: z.number().describe("Input amount (in number format, not ERC20 decimals)"),
  },
  async (params) => {
    try {
      const validation = validateEnvironment();
      if (!validation.isValid) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå Environment validation failed:\n\n${validation.errors.join('\n')}`,
            },
          ],
        };
      }

      if (!validateTokenAddresses(params.tokenIn, params.tokenOut)) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå Invalid token addresses provided`,
            },
          ],
        };
      }

      const estimation = await estimateSwapOutput(params.tokenIn, params.tokenOut, params.amountIn);
      
      return {
        content: [
          {
            type: "text",
            text: `üìä **Swap Estimation**\n\nüìã **Swap Details:**\n‚Ä¢ Token In: ${params.tokenIn}\n‚Ä¢ Token Out: ${params.tokenOut}\n‚Ä¢ Amount In: ${params.amountIn}\n\nüí∞ **Estimation Results:**\n‚Ä¢ Estimated Amount Out: ${estimation.estimatedAmountOut}\n‚Ä¢ Path: ${estimation.path?.join(' ‚Üí ') || 'Direct'}\n‚Ä¢ Pools Used: ${estimation.pools?.length || 0}`,
          },
        ],
      };
    } catch (e) {
      return {
        content: [
          {
            type: "text",
            text: `‚ùå Failed to estimate swap output: ${e}`,
          },
        ],
      };
    }
  }
);

// Execute Swap Tool
server.tool(
  "executeSwap",
  "Execute a token swap using the router contract with automatic decimal detection and allowance checking",
  {
    tokenIn: z.string().describe("Input token address"),
    tokenOut: z.string().describe("Output token address"),
    amount: z.number().describe("Amount to swap (in number format, not ERC20 decimals)"),
  },
  async (params) => {
    try {
      const validation = validateEnvironment();
      if (!validation.isValid) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå Environment validation failed:\n\n${validation.errors.join('\n')}`,
            },
          ],
        };
      }

      if (!validateTokenAddresses(params.tokenIn, params.tokenOut)) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå Invalid token addresses provided`,
            },
          ],
        };
      }

      let approvalTxHash: string | null = null;
      
      const result = await executeSwap(
        params.tokenIn,
        params.tokenOut,
        params.amount,
        (txHash: string | null) => {
          approvalTxHash = txHash;
        }
      );
      
      const isNativeToken = result.allowanceInfo.isNativeToken;
      const needsApproval = result.allowanceInfo.needsApproval;
      
      return {
        content: [
          {
            type: "text",
            text: `‚úÖ **Swap Executed Successfully**\n\nüìã **Swap Details:**\n‚Ä¢ Token In: ${params.tokenIn} (${result.tokenInfo.tokenIn.symbol})\n‚Ä¢ Token Out: ${params.tokenOut} (${result.tokenInfo.tokenOut.symbol})\n‚Ä¢ Amount: ${params.amount}\n‚Ä¢ Token In Decimals: ${result.tokenInfo.tokenIn.decimals}\n‚Ä¢ Token Out Decimals: ${result.tokenInfo.tokenOut.decimals}\n\nüîê **Allowance Info:**\n‚Ä¢ Is Native Token: ${isNativeToken ? 'Yes' : 'No'}\n‚Ä¢ Needs Approval: ${needsApproval ? 'Yes' : 'No'}\n\nüîó **Transaction Details:**\n‚Ä¢ Approval TX Hash: ${approvalTxHash || 'N/A'}\n‚Ä¢ Swap TX Hash: ${result.transactionHash || 'N/A'}\n‚Ä¢ Gas Used: ${result.gasUsed?.toString() || 'N/A'}\n‚Ä¢ Status: ${result.status === 1 ? 'Success' : 'Failed'}`,
          },
        ],
      };
    } catch (e) {
      return {
        content: [
          {
            type: "text",
            text: `‚ùå Failed to execute swap: ${e}`,
          },
        ],
      };
    }
  }
);

// Get Token Info Tool
server.tool(
  "getTokenInfo",
  "Get detailed information about an ERC20 token",
  {
    tokenAddress: z.string().describe("Token contract address"),
  },
  async (params) => {
    try {
      const validation = validateEnvironment();
      if (!validation.isValid) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå Environment validation failed:\n\n${validation.errors.join('\n')}`,
            },
          ],
        };
      }

      if (!validateTokenAddresses(params.tokenAddress, params.tokenAddress)) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå Invalid token address provided`,
            },
          ],
        };
      }

      const tokenInfo = await getTokenInfo(params.tokenAddress);
      
      return {
        content: [
          {
            type: "text",
            text: `ü™ô **Token Information**\n\nüìã **Token Details:**\n‚Ä¢ Address: ${tokenInfo.address}\n‚Ä¢ Name: ${tokenInfo.name}\n‚Ä¢ Symbol: ${tokenInfo.symbol}\n‚Ä¢ Decimals: ${tokenInfo.decimals}\n‚Ä¢ Total Supply: ${tokenInfo.totalSupply}`,
          },
        ],
      };
    } catch (e) {
      return {
        content: [
          {
            type: "text",
            text: `‚ùå Failed to get token info: ${e}`,
          },
        ],
      };
    }
  }
);

// Get Available Base Tokens Tool
server.tool(
  "getAvailableBaseTokens",
  "Get list of available base tokens for pool creation",
  {},
  async () => {
    try {
      const baseTokens = getAvailableBaseTokens();
      
      return {
        content: [
          {
            type: "text",
            text: `ü™ô **Available Base Tokens**\n\nüìã **Base Tokens:**\n${baseTokens.map(token => `‚Ä¢ ${token.symbol}: ${token.address}`).join('\n')}\n\nüí° **Usage:** These tokens are commonly used as base pairs for liquidity pools.`,
          },
        ],
      };
    } catch (e) {
      return {
        content: [
          {
            type: "text",
            text: `‚ùå Failed to get base tokens: ${e}`,
          },
        ],
      };
    }
  }
);



async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  
  // Validate environment on startup
  const validation = validateEnvironment();
  const chainConfig = getChainConfig();
  
  // All logging must go to stderr to avoid interfering with MCP protocol
  console.error(`Kuru Exchange MCP Server v1.0.0 running on stdio`);
  console.error(`Wallet Address: ${account.address}`);
  console.error(`Chain: ${chainConfig.name} (${chainConfig.chainId})`);
  console.error(`RPC URL: ${chainConfig.rpcUrl}`);
  console.error(`Kuru API: ${chainConfig.kuruApiUrl}`);
  
  if (validation.isValid) {
    console.error(`Status: ‚úÖ Environment validated - Ready for Kuru exchange operations`);
  } else {
    console.error(`Status: ‚ö†Ô∏è Environment validation failed - Some tools may not work`);
    console.error(`Errors: ${validation.errors.join(', ')}`);
  }
}

// Ensure stdout is only used for MCP protocol communication
process.stdout.on('error', (err) => {
  console.error('STDOUT Error:', err);
});

// Override console.log to prevent stdout pollution
const originalConsoleLog = console.log;
console.log = (...args) => {
  console.error('[REDIRECTED FROM STDOUT]:', ...args);
};

main().catch((error) => {
  console.error("Fatal error in Kuru Exchange MCP main():", error);
  process.exit(1);
});
